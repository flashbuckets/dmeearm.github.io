<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="google-site-verification" content="aexITLS38FdIRzwj25OVWxm87rpa9l-UV0URTyC9cTs" />
  <title>
    Nginx配置文件解析之一
    
  </title>
  <link rel="stylesheet" href="/css/site.css">
  <!--<link type="text/css" rel="stylesheet" href="http://fonts.googleapis.com/css?family=Ubuntu+Mono|Asap:400,700,400italic">-->
  <link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" />
<!--
  
-->
  

  
</head>
<body>
  <div class="top-bar">
<!--    
    In September, come to France to <a href="http://surfcamp.lewagon.org"><strong>code</strong> & <strong>surf</strong></a>!
    -->
  </div>

  <div class="header-container">
    <header class="inner">
      <nav>
        <a class="" href="/">About</a>
        <a class="" href="/blog/">Blog</a>
        <a class="" href="/project/">Project</a>
        <a class=" contact" href="/contact/">Contact</a>
        <!--<a href="https://github.com/dmeearm">Github</a>-->
      </nav>
      <div class="pull-right right logo">
        <div class="name">
          <a href="/">aweth0me</a><br />
          <small>
            <em>
                <a href="/">System Development Engineer</a>
            </em>
          </small>
        </div>
        <img class="avatar" src="/images/YongYuan.png" alt="My profile picture" />
      </div>
      <div class="clear"></div>
    </header>
    <div class="clear"></div>
  </div>

  

<article>
  <h1 class="inner">
    Nginx配置文件解析之一
  </h1>

  <p class="meta">Sunday 14 December 2014</p>

  

  <div class="post">
    <p>现在针对nginx源码分析的blog和文章已经很多了，之前我也看过不少，大家的分析都很不错。太多重复的内容就不写了，主要想针对在我分析代码和查阅blog的过程中，发现的一些比较晦涩或者某些细节有待展开讨论的地方，给出我的自己理解和看法，希望跟大家交流和学习。</p>

<p>使用的nginx版本是nginx-1.0.6，我最开始看的代码是0.7.62，新的版本在功能和稳定性上做了很多的工作。</p>

<p>在分析的时候，我尽量简单明了，不太重要的地方一带而过，具体地大家可以去读代码。相对复杂或者晦涩的地方，将详细展开。</p>

<p>首先我们从配置文件开始，下面的分析是建立在网友对nginx的配置文件结构有大概熟悉为前提，这样才可以很好的理解代码。</p>

<p>这里有必要提醒一点：原始代码目录中ngx_modules这个结构，是找不到它的定义和初始化，要看到它，你必须执行configure，make，在原来的代码目录下会出现一个objs文件夹，里面的3个文件ngx_auto_config.h，ngx_auto_headers.h，ngx_modules.c，需要在建source insight工程时也包含进去，这样有利于我们把握整个代码结构。呵呵，有意思的是，nginx的configure文件是作者手工写的，里面有许多管理代码工程的方法，有时间的话，也是值得学习下的。</p>

<p>1.ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle);</p>

<p>配置文件的解析相关的处理主要在ngx_init_cycle函数中被调用。既然如此，我们就先说说ngx_init_cycle函数吧。</p>

<p>它需要一个参数类型为ngx_cycle_t <em>，返回值也是一个ngx_cycle_t</em>，与此同时我们注意到参数名为old_cycle，那么这个函数的作用是啥呢？很明显是由old得到一个new。其中ngx_cycle_t的结构保存一些全局的配置和信息。这个函数具体作用将在reconfig(重读配置文件)的时候得到体现，可以理解为old_cycle是当前正在使用的配置信息，当配置文件做了某些修改之后，ngx_init_cycle通过old_cycle中的一些数据，对new_cycle进行一些设置，在经过进一步的配置解析之后，就可以得到一个new cycle。</p>

<p>2.char *ngx_conf_parse(ngx_conf_t *cf, ngx_str_t *filename)</p>

<p>当我们使用sourceinsight查看这个函数的调用情况时，会发现调用它的地方很多。其实，入口点就在ngx_init_cycle中对ngx_conf_parse调用，后面的所有的调用可以看作是在此之后的递归调用。为什么会是这个样子呢？原因在于nginx是一边读取配置信息，一边解析执行相关的处理，具体一点讲，就是“读一行，执行一行”，一行的定义在这里是指以分号或者是“{”和“}”等结尾的一行，例如：我们解析到http {}，我们就调用针对httpblock的处理，在处理的时候我们又会碰到server {}，自然就会调用server block的处理。。。以此类推！。</p>

<p>对配置文件的读取主要在函数ngx_conf_read_token中，这个函数每次会把NGX_CONF_BUFFER(即4KB)大小的配置信息读到内存buf中，然后对该buf进行分析。在该函数外，主要通过该函数的返回值在做不同的处理，关于它的返回值的含义，大家可以去细细读下代码，意义很明确！</p>

<p>配置指令我们通过上面的操作就可以拿到了，以空格分开的各个字符串被保存在一个字符串数组里(即cf-&gt;args)，这一点代码体现的很明显。之后呢，我们就调用ngx_conf_handler函数来处理当前拿到的这行配置。这里我们先从总体上说一下ngx_conf_handler这个函数的工作原理：”它遍历系统中所有的模块配置，找到特定模块，并匹配特定命令，然后执行“。下面我们展开来讲一下。</p>

<p>nginx会将所有的模块分类管理，自然各个模块被划分到了一个个“集合”中去，同样一个模块下的指令也是分类的(如属于哪类模块，配置在哪些位置是正确的等等)，所以在每次调用ngx_conf_parse的时候都会指出”我这次解析的配置信息是啥类型“，举例：</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">conf</span><span class="p">.</span><span class="n">module_type</span><span class="o">=</span> <span class="n">NGX_CORE_MODULE</span><span class="p">;</span>
<span class="n">conf</span><span class="p">.</span><span class="n">cmd_type</span> <span class="o">=</span> <span class="n">NGX_MAIN_CONF</span><span class="p">;</span>
</code></pre></div>
<p>即解析得到的指令我们将core module类型中查找，并且在找到的module中类型为main conf的指令。</p>

<p>在进入重点之前，我们先看一个地方，就是cf-&gt;handler的处理，它是做什么用的呢？是这样的，nginx的通用处理函数ngx_conf_handler主要是针对cf-&gt;args的字符串数组来使用的，像有的配置，如types，charset_map，并不是单纯的字符串数组，指令的参数可能会放在{}中，这样通用的解析和处理函数就不适用了。通过我们注册cf-&gt;handler，我们就可以对下面{}中参数做常规的配置处理了。</p>

<p>我们进入到ngx_conf_handler函数中，看看它的工作机理。</p>

<ol>
<li>static ngx_int_t ngx_conf_handler(ngx_conf_t *cf,ngx_int_t last)</li>
</ol>

<p>参数last是ngx_conf_read_token解析的返回结果。强调一点的是，cf-&gt;args中已经保存了我们需要的各个参数。</p>

<p>接下来的处理分4步走：</p>

<p>(1)  模块匹配</p>

<p>代码显示的很明显，它首先会根据你指定的类型，对特定的模块进行查找。</p>

<p>(2)  command匹配</p>

<p>找到匹配的模块之后会遍历该模块下的command数组，来从中找到它需要找command信息。如果字面上匹配，还要进行command类型的配置检查，如果此时类型不匹配，nginx会报告给你。</p>

<p>(3)  参数个数匹配</p>

<p>主要检查对个数有严格要求的command，对于任意个数(即NGX_CONF_ANY)的command，就直接处理了。</p>

<p>关于参数个数，nginx定义了一些宏，如NGX_CONF_TAKEx(x代表1,2,3等，表示可配置一个，两个，三个参数。。)，还有像1MORE,2MORE，意思也很明确。注意的是，对于有个数限制的command，最多可配置的个数为8个，即NGX_CONF_MAX_ARGS，这个在写自己的module时要注意，我吃过这方面的亏。。。</p>

<p>(4)  执行command(即set函数)。</p>

<p>好了，前面的检查工作做完之后，就要真正去执行相关的操作，生成module的配置信息了。</p>

<p>这里涉及command的类型问题，搞清楚它对后面的理解很重要。Let’s go!</p>

<p>NGX_DIRECT_CONF,NGX_MAIN_CONF,NGX_HTTP_MAIN_CONF,NGX_HTTP_SRV_CONF,NGX_HTTP_LOC_CONF等</p>

<p>其中NGX_DIRECT_CONF一般是在http块等之外的配置, NGX_HTTP_MAIN_CONF是直接配置在http块中的，NGX_HTTP_SRV_CONF配置在server块中，NGX_HTTP_LOC_CONF配置在location中等等。</p>

<p>我们来看cf-&gt;ctx这个成员，它的类型是void *，到这里你大概会猜到它的用处，肯定是在不同的条件下转来转去！</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">在ngx_init_cycle中我们发现最初cf-&gt;ctx的值由cycle-&gt;conf_ctx赋值得到，cycle-&gt;conf_ctx是一个void ****类型。(-_-!)
</code></pre></div>
<p>在ngx_init_cycle中有这样关键的一句：</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">cycle</span><span class="o">-&gt;</span><span class="n">conf_ctx</span> <span class="o">=</span><span class="n">ngx_pcalloc</span><span class="p">(</span><span class="n">pool</span><span class="p">,</span> <span class="n">ngx_max_module</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">));</span>
</code></pre></div>
<p>所以，这里ngx_max_module是系统中所有module的总数，conf_ctx在这一句中用来给每个module占一个位置(一个指针)，但是每个位置到底指向啥东西呢？反正是个void <em>，指啥都行，一般都只指向一些模块的配置结构，但是对于有些模块，我们要拿到它，要透过n层的指针(例如void *</em>**)来拿到，这样的设计是为了逻辑分层和模块划分。</p>

<p>兜了一圈，我们发现最终这些指针数组的成员赋值都会在这里的第4步来完成：</p>

<p>这里分3种情况：</p>

<p>(1)  NGX_DIRECT_CONF</p>

<p>对于那些游离于{}之外的配置，一般属于ngx_core_conf_t的配置内容，在ngx_init_cycle的时候已经对NGX_CORE_MODULE类型的模块进行了初始化（模块需要有init函数），这里根据配置信息，set函数会做配置结构内中成员的赋值。</p>

<p>(2)  NGX_MAIN_CONF</p>

<p>这样的配置包括event，http等，他们没有init函数，所以实际的空间分配需要在set函数内完成，于是就有了：</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">conf</span> <span class="o">=&amp;</span><span class="p">(((</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="p">)[</span><span class="n">ngx_modules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">]);</span> <span class="c1">//取指针的地址</span>

<span class="n">rv</span> <span class="o">=</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">conf</span><span class="p">);</span>  <span class="c1">// 指针在函数内被赋值</span>

<span class="c1">// set中conf参数是一个二重指针，这也就有个之后在ngx_http_block中的语句：</span>

<span class="n">ctx</span> <span class="o">=</span><span class="n">ngx_pcalloc</span><span class="p">(</span><span class="n">cf</span><span class="o">-&gt;</span><span class="n">pool</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">ngx_http_conf_ctx_t</span><span class="p">));</span>

<span class="o">*</span><span class="p">(</span><span class="kt">ngx_http_conf_ctx_t</span> <span class="o">**</span><span class="p">)</span> <span class="n">conf</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
</code></pre></div>
<p>3）其他</p>

<p>其实这里的“其他”，主要是一些server和location的类型的command，这些command大量的集中于http的相关配置中。</p>

<p>我们先来看ngx_http_conf_ctx_t结构：</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">typedefstruct</span> <span class="p">{</span>

    <span class="kt">void</span>       <span class="o">**</span><span class="n">main_conf</span><span class="p">;</span>

    <span class="kt">void</span>       <span class="o">**</span><span class="n">srv_conf</span><span class="p">;</span>

    <span class="kt">void</span>       <span class="o">**</span><span class="n">loc_conf</span><span class="p">;</span>

<span class="p">}</span> <span class="kt">ngx_http_conf_ctx_t</span><span class="p">;</span>
</code></pre></div>
<p>这里有一点需要交代的是，像http模块下，有一些所谓的子模块，而这些子模块基本上都是http中server或者location中的一些配置。这些配置通过模块中ctx_index，以数组的形式，将他们的配置结构的指针保存在srv_conf或loc_conf中，这就是他们的类型为什么会是void **。</p>

<p>看下面的行代码：</p>

<p>cmd-&gt;conf是cf-&gt;ctx成员的位移，这里的处理就是把该位置的成员当成一个指针来处理，而实际上，它是一个二级指针，即子模块配置的指针的数组！</p>
<div class="highlight"><pre><code class="language-c++" data-lang="c++"><span class="n">confp</span> <span class="o">=*</span><span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">cf</span><span class="o">-&gt;</span><span class="n">ctx</span> <span class="o">+</span> <span class="n">cmd</span><span class="o">-&gt;</span><span class="n">conf</span><span class="p">);</span>

<span class="n">conf</span> <span class="o">=</span> <span class="n">confp</span><span class="p">[</span><span class="n">ngx_modules</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">ctx_index</span><span class="p">];</span>      <span class="c1">// 拿到配置结构   </span>

<span class="n">rv</span> <span class="o">=</span><span class="n">cmd</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">conf</span><span class="p">);</span>      <span class="c1">// 做处理</span>
</code></pre></div>
<p>最后说明一下，开始提到的那个void ****类型成员，使用这种类型的原因我们可以在ngx_events_block函数中找到答案。</p>

  </div>
</article>

<section class="post-footer-self-promotion inner">

	<a href="http://weibo.com/u/1736566822" target="_blank">
	<img class="avatar" src="/images/YongYuan.png" />
	</a>
	
	<p>
	<!--
	Do you like <strong>coding</strong>? Do you like or would you like to learn <strong>surfing</strong>? Book your tickets for the next Le Wagon <a href="http://surfcamp.lewagon.org"><strong>Code &amp; Surf Camp</strong></a>!
        -->
	Thanks for reading! Do you want to keep up with what I do?
	<a href="http://weibo.com/u/1736566822">Follow me on Weibo</a>.
	
	</p>

	<div id="more-articles">
	  
	  <p>
		If you liked this, feel free to <a href="/blog">browse other articles on my blog</a>.
	  </p>
	  
	</div>
<!--	
    <a href="https://twitter.com/marcgg" class="twitter-follow-button" data-show-count="false" data-size="large">Follow @marcgg</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

    <a href="https://twitter.com/share" class="twitter-share-button" data-via="marcgg" data-size="large">Tweet</a>
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
-->
  </div>
  
</section>

<div class="separator"></div>

<section class="comments inner">
  <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'dmeearm'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>

  <div class="separator"></div>

  <div  style="border-bottom: 1px solid #ddd"></div>
  <footer>
    <p>
      Made with <a href="http://jekyllrb.com/">Jekyll</a>,
      hosted on <a href="https://github.com/dmeearm/dmeearm.github.io">Github Pages</a>. Theme inspired by <a href="http://marcgg.com">marcgg.com</a>.
    </p>
    <ul class="links">
      <li>
        <a href="https://github.com/dmeearm" title="See my code on GitHub">
          <i class="icon-github"></i>
        </a>
      </li>
      <li>
        <a href="https://twitter.com/yujieding" title="Follow me on Twitter">
          <i class="icon-twitter"></i>
        </a>
      </li>
      <li>
        <a href="http://weibo.com/u/1736566822" title="Contact me on Weibo"></a>
          <i class="icon-feed"></i>
      </li>
      <li>
        <a href="/feed.xml" title="Subscribe to my blog with RSS">
          <i class="icon-feed"></i>
        </a>
      </li>
    </ul>
  </footer>

    <script type="text/x-mathjax-config">
    // 添加数学公式支持
    MathJax.Hub.Config({
    tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
    });

    MathJax.Hub.Queue(function() {
    // Fix <code> tags after MathJax finishes running. This is a
    // hack to overcome a shortcoming of Markdown. Discussion at
    // https://github.com/mojombo/jekyll/issues/199
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
    });
    </script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-40867989-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

    /*!
     * http://github.com/ssaunier/track-outbound-links
     * Copyright 2013 Sébastien Saunier
     * @license MIT
     */
    !function(e,t){function n(){for(var n=t.getElementsByTagName("a"),a=[],r=0;r<n.length;++r){var o=n[r];o.host!=e.location.host&&a.push(o)}return a}function a(n){for(var a=n.srcElement||n.target;a&&("undefined"==typeof a.tagName||"a"!=a.tagName.toLowerCase()||!a.href);)a=a.parentNode;a&&a.href&&(e._gaq&&_gaq.push(["_trackEvent","Outbound link","Click",a.href]),(!a.target||a.target.match(/^_(self|parent|top)$/i))&&(setTimeout(function(){t.location.href=a.href},150),n.preventDefault?n.preventDefault():n.returnValue=!1))}e.addEventListener("load",function(){var e=n();for(var t in e)e[t].addEventListener("click",a)})}(window,document);
    var links = document.links;
    for (var i = 0, linksLength = links.length; i < linksLength; i++) {
       if (links[i].hostname != window.location.hostname) { links[i].target = '_blank'; }
    }

    /*
     * Detect if we are included in an iframe => move.
     */
    if (window.top !== window.self
        && !window.self.location.href.match(/headsha\.re/))
    {
      window.top.location.replace(window.self.location.href);
    }
  </script>

  <!--
  <script id="_webengage_script_tag" type="text/javascript">
    // var _weq = _weq || {};
    // _weq['webengage.licenseCode'] = '11b563c38';
    // _weq['webengage.widgetVersion'] = "4.0";

    // (function(d){
    //   var _we = d.createElement('script');
    //   _we.type = 'text/javascript';
    //   _we.async = true;
    //   _we.src = (d.location.protocol == 'https:' ? "https://ssl.widgets.webengage.com" : "http://cdn.widgets.webengage.com") + "/js/widget/webengage-min-v-4.0.js";
    //   var _sNode = d.getElementById('_webengage_script_tag');
    //   _sNode.parentNode.insertBefore(_we, _sNode);
    // })(document);
  </script>
  -->

</body>
</html>
